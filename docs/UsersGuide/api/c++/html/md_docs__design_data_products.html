<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>F´ Flight Software - C/C++ Documentation: Data Products</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">F´ Flight Software - C/C++ Documentation
   &#160;<span id="projectnumber">devel</span>
   </div>
   <div id="projectbrief">A framework for building embedded system applications to NASA flight quality standards.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_docs__design_data_products.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Data Products </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md29"></a>
1. Introduction</h1>
<p>A <b>data product</b> is any data that is produced by an embedded system, stored on board the system, and transmitted to the ground, typically in priority order. F Prime provides several features for managing the generation, storage, and downlink of data products. In this section, we document those features.</p>
<h1><a class="anchor" id="autotoc_md30"></a>
2. Basic Concepts</h1>
<p>First we explain some basic concepts.</p>
<h2><a class="anchor" id="autotoc_md31"></a>
2.1. Records, Containers, and Dictionaries</h2>
<p>F Prime data products are based on <b>records</b> and <b>containers</b>. A record is a basic unit of data. For example, it may be a struct, an array of typed objects of statically known size, or an array of bytes of statically unknown size. A container has an identifier and a priority and stores records. In C++, a container is represented as a class object with member fields that (1) store header data and (2) store an <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code> object pointing to the memory that stores the records.</p>
<p>The set of all container specifications forms the <b>data product dictionary</b>. To manage the data product dictionary, F Prime uses the same general approach as for commands, telemetry, events, and parameters:</p>
<ol type="1">
<li>Each component <em>C</em> specifies records and containers. The container IDs are local to <em>C</em>. Typically they have the values 0, 1, 2, ... .</li>
<li>Each instance <em>I</em> of <em>C</em> contributes one container <em>I.c</em> to the dictionary for each container <em>c</em> defined in <em>C</em>. The global identifier for <em>I.c</em> is the base identifier of <em>I</em> plus the local identifier for <em>c</em>. For example, if the base identifier is 0x1000, then the global identifiers might be 0x1000, 0x1001, 0x1002, ... .</li>
<li>For any topology <em>T</em>, the global identifiers <em>I.c</em> for all the component instances of <em>T</em> form the data product dictionary for <em>T</em>.</li>
</ol>
<h2><a class="anchor" id="autotoc_md32"></a>
2.2. F Prime Components</h2>
<p>Typically a data product system in an F Prime application consists of the following components:</p>
<ol type="1">
<li>One or more <b>data product producers</b>. These components produce data products and are typically mission-specific. For example, they may produce science data.</li>
</ol>
<ol type="1">
<li>Standard F Prime components for managing data products.<ol type="a">
<li>A <b>data product manager</b>. This component allocates memory for empty containers. It also forwards filled containers to the data product writer. See <a class="el" href="svc_2_dp_manager_2docs_2sdd_8md.html">`Svc::DpManager`</a>.</li>
</ol>
<ol type="a">
<li>A <b>data product writer</b>. This component receives filled containers from data product producers. It writes the contents of the containers to non-volatile storage. See <a class="el" href="svc_2_dp_writer_2docs_2sdd_8md.html">`Svc::DpWriter`</a>.</li>
</ol>
<ol type="a">
<li>A <b>data product catalog</b>. This component maintains a database of available data products. By command, it downlinks and deletes data products. See <a class="el" href="svc_2_dp_catalog_2docs_2sdd_8md.html">`Svc::DpCatalog`</a>.</li>
</ol>
<ol type="a">
<li>A <b>data product processor</b>. This component is not yet developed. When it is developed, it will perform in-memory processing on data product containers.</li>
</ol>
</li>
</ol>
<p>Note that when using data products, you need to develop only the producer components. The other components are provided by F Prime.</p>
<h1><a class="anchor" id="autotoc_md33"></a>
3. Producer Components</h1>
<p>In this section we provide more detail about producer components.</p>
<h2><a class="anchor" id="autotoc_md34"></a>
3.1. Activities</h2>
<p>A producer component typically repeats the following activities, as often as necessary:</p>
<ol type="1">
<li>Request a container from a data manager component.</li>
<li>When the container is received, serialize records into the container. This action fills the container with data.</li>
<li>When the container is full, send the container to the data product manager, which forwards it to the data product writer.</li>
</ol>
<p>The FPP model and the autocoded C++ have several features that support these activities. We discuss these features in the following sections.</p>
<h2><a class="anchor" id="autotoc_md35"></a>
3.2. FPP Modeling</h2>
<p>In this section we summarize the features of the FPP modeling language used in constructing data product producer components. Each of these features is fully documented in <a href="https://nasa.github.io/fpp/fpp-users-guide.html"><em>The FPP User's Guide</em></a> and <a href="https://nasa.github.io/fpp/fpp-spec.html"><em>The FPP Language Specification</em></a>.</p>
<h3><a class="anchor" id="autotoc_md36"></a>
3.2.1. Ports</h3>
<p>FPP provides the following special ports for managing data products:</p>
<ol type="1">
<li>A <b>product get port</b> of type <a class="el" href="fw_2_dp_2docs_2sdd_8md.html">`Fw::DpGet`</a>. This is an output port for synchronously requesting memory from a buffer manager. The request is served on the thread that invokes the port and causes a mutex lock to be taken on that thread. Example syntax: <div class="fragment"><div class="line">product get port productGetOut</div>
</div><!-- fragment --></li>
</ol>
<ol type="1">
<li>A <b>product request port</b> of type <a class="el" href="fw_2_dp_2docs_2sdd_8md.html">`Fw::DpRequest`</a>. This is an output port for asynchronously requesting memory from a data product manager. The request is served on the thread of the data product manager. This approach incurs the overhead of a separate thread, but it does not require the requesting thread to take a lock. Example syntax: <div class="fragment"><div class="line">product request port productRequestOut</div>
</div><!-- fragment --></li>
</ol>
<ol type="1">
<li>A <b>product receive port</b> of type <a class="el" href="fw_2_dp_2docs_2sdd_8md.html">`Fw::DpResponse`</a>. This is an input port for receiving an empty container in response to an asynchronous request. Example syntax: <div class="fragment"><div class="line">async product recv port productRecvIn</div>
</div><!-- fragment --></li>
</ol>
<ol type="1">
<li>A <b>product send port</b> of type <a class="el" href="fw_2_dp_2docs_2sdd_8md.html">`Fw::DpSend`</a>. This is an output port for sending a filled container to a data product writer. Example syntax: <div class="fragment"><div class="line">product send port productSendOut</div>
</div><!-- fragment --></li>
</ol>
<p>Each data product producer component must have the following ports in its component model:</p>
<ol type="1">
<li>One or both of a <code>product</code> <code>get</code> port and a <code>product</code> <code>request</code> port.</li>
</ol>
<ol type="1">
<li><p class="startli">A <code>product</code> <code>send</code> port.</p>
<p class="startli">A component that has a <code>product</code> <code>request</code> port must also have a <code>product</code> <code>receive</code> port.</p>
</li>
</ol>
<h3><a class="anchor" id="autotoc_md37"></a>
3.2.2. Records</h3>
<p>A record is a unit of data. When defining a producer component, you can specify one or more records. A record specification consists of a name, a type specifier, and an optional identifier. The type specifier may be one of the following:</p>
<ol type="1">
<li>An FPP type <em>T</em>. In this case, the record contains a single value of type <em>T</em>. <em>T</em> may be any FPP type, including a struct or array type.</li>
</ol>
<ol type="1">
<li>An FPP type <em>T</em> followed by the keyword <code>array</code>. In this case, the record is an array of values of type <em>T</em> of statically unknown size. The size of the array is stored in the record.</li>
</ol>
<p>In either case, <em>T</em> may be any FPP type, including a struct or array type.</p>
<p>Example syntax: </p><div class="fragment"><div class="line">@ A struct with a fixed-size member array</div>
<div class="line">struct FixedSizeData {</div>
<div class="line">  data: [1024] F32</div>
<div class="line">}</div>
<div class="line">@ A record containing fixed-size data</div>
<div class="line">product record FixedSizeDataRecord: FixedSizeData id 0x00</div>
<div class="line">@ A record containing a variable-size array</div>
<div class="line">product record F32ArrayRecord: F32 array id 0x01</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md38"></a>
3.2.3. Containers</h3>
<p>A container is a data structure that stores records. When defining a producer component, you can specify one or more containers. Each container specified in a component can store any of the records specified in the component.</p>
<p>A container specification consists of a name, an optional identifier, and an optional default priority. The default priority is the priority to use if no other priority is specified for the container during operations. Example syntax: </p><div class="fragment"><div class="line">product container C1</div>
<div class="line">product container C2 id 0x01 default priority 10</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md39"></a>
3.3. Autocoded C++</h2>
<p>The autocoded C++ base class for a producer component <em>C</em> provides the following API elements:</p>
<ol type="1">
<li>Enumerations defining the available container IDs, container priorities, and record IDs.</li>
</ol>
<ol type="1">
<li>A member class <em>C</em> <code>::DpContainer</code>. This class is derived from <a class="el" href="fw_2_dp_2docs_2sdd_8md.html">`Fw::DpContainer`</a> and represents a container specialized to the data products defined in <em>C</em>. Each instance of <em>C</em> <code>::DpContainer</code> is a wrapper for an <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code> <em>B</em>, which points to allocated memory. The class provides operations for serializing the records defined in <em>C</em> into the memory pointed to by <em>B</em>. There is one operation <em>C</em> <code>::DpContainer::serialize_</code> <em>R</em> for each record <em>R</em> defined in <em>C</em>. For the serialized format of each record, see the documentation for <a class="el" href="fw_2_dp_2docs_2sdd_8md.html">`Fw::DpContainer`</a>.</li>
</ol>
<ol type="1">
<li>If <em>C</em> has a <code>product</code> <code>get</code> port, a member function <code>dpGet_</code> <em>c</em> for each container <em>c</em> defined in <em>C</em>. This function takes a data size and a reference to a data product container <em>D</em>. It invokes <code>productGetOut</code>, which is typically connected to a data product manager component. In the nominal case, the invocation returns an <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a></code> <em>B</em> large enough to store a data product packet with the requested data size. The <code>dpGet</code> function then uses the ID and <em>B</em> to initialize <em>D</em>. It returns a status value indicating whether the buffer allocation succeeded.</li>
</ol>
<ol type="1">
<li>If <em>C</em> has a <code>product</code> <code>request</code> port, a member function <code>dpRequest_</code> <em>c</em> for each container <em>c</em> defined in <em>C</em>. This function takes a data size. It sends out a request on <code>productRequestOut</code>, which is typically connected to a data product manager component. The request is for a buffer large enough to store a data product packet with the requested data size.</li>
</ol>
<ol type="1">
<li>If <em>C</em> has a <code>product</code> <code>recv</code> port, a pure virtual member function <code>dpRecv_</code> <em>c</em> <code>_handler</code> for each container <em>c</em> defined in <em>C</em>. When a fresh container arrives in response to a <code>dpRequest</code> invocation, the autocoded C++ uses the container ID to select and invoke the appropriate <code>dpRecv</code> handler. The implementation of <em>C</em> must override each handler to provide the mission-specific behavior for filling in the corresponding container. The arguments to <code>dpRecv_</code> <em>c</em> <code>_handler</code> provide (1) a reference to the container, which the implementation can fill in; and (2) a status value indicating whether the container is valid. An invalid container can result if the buffer allocation fails.</li>
</ol>
<ol type="1">
<li>A member function <code>dpSend</code> for sending a filled data product container. This function takes a reference to a container <em>c</em> and an optional time tag. It does the following:<ol type="a">
<li>If no time tag is provided, then invoke <code>timeGetOut</code> to get the system time and use it to set the time tag.</li>
</ol>
<ol type="a">
<li>Store the time tag into <em>c</em>.</li>
</ol>
<ol type="a">
<li>Send <em>c</em> on <code>productSendOut</code>.</li>
</ol>
</li>
</ol>
<ol type="1">
<li><p class="startli">Constant expressions representing the sizes of the records.</p><ol type="a">
<li>If a record <em>R</em> holds a single value, then the expression <code>SIZE_OF_</code> <em>R</em> <code>_RECORD</code> evaluates to the size of that record.</li>
</ol>
<ol type="a">
<li>Otherwise <em>R</em> is an array record. In this case the expression <code>SIZE_OF_</code> <em>R</em> <code>_RECORD(</code> <em>size</em> <code>)</code> evaluates to the size of an array record <em>R</em> with <em>size</em> array elements.</li>
</ol>
<p class="startli">You can use these expressions to compute data sizes when requesting data product buffers. For example, if a component specifies a record <code>Image</code>, then inside the component implementation the expression <code>10 * SIZE_OF_Image_RECORD</code> represents the size of the storage necessary to hold 10 <code>Image</code> records.</p>
</li>
</ol>
<h2><a class="anchor" id="autotoc_md40"></a>
3.4. Unit Test Support</h2>
<p>In F Prime, each component <em>C</em> comes with auto-generated classes <em>C</em> <code>TesterBase</code> and <em>C</em> <code>GTestBase</code> for writing unit tests against <em>C</em>. <em>C</em> <code>GTestBase</code> is derived from <em>C</em> <code>TesterBase</code>; it provides test macros based on the Google Test framework.</p>
<p>To write unit tests, you construct a class <em>C</em> <code>Tester</code>. Typically <em>C</em> <code>Tester</code> is derived from <em>C</em> <code>GTestBase</code> and uses the Google Test framework macros. If for some reason you can't use the Google Test framework (e.g., because you are running on a platform that does not support it), then your <em>C</em> <code>Tester</code> class can be derived from <em>C</em> <code>TesterBase</code>.</p>
<p>This section documents the unit test support for producer components.</p>
<h3><a class="anchor" id="autotoc_md41"></a>
3.4.1. The TesterBase Class</h3>
<p><b>History data structures:</b> The class <em>C</em> <code>TesterBase</code> provides the following histories:</p>
<ol type="1">
<li>If <em>C</em> has a product get port, then <em>C</em> <code>TesterBase</code> has a history called <code>productGetHistory</code>. Each element in the history is of type <code>DpGet</code>. <code>DpGet</code> is a struct with fields storing the container ID and the size emitted on the product get port.</li>
</ol>
<ol type="1">
<li>If <em>C</em> has a product request port, then <em>C</em> <code>TesterBase</code> has a corresponding history called <code>productRequestHistory</code>. Each element in the history is of type <code>DpRequest</code>. <code>DpRequest</code> is a struct with fields storing the container ID and the size emitted on the product request port.</li>
</ol>
<ol type="1">
<li><em>C</em> <code>TesterBase</code> has a history called <code>productSendHistory</code>. Each element in the history is of type <code>DpSend</code>. <code>DpSend</code> is a struct with fields storing the container ID and a shallow copy of the buffer emitted on the product send port.</li>
</ol>
<p><b>History functions:</b> The class <em>C</em> <code>TesterBase</code> provides the following functions for managing the histories:</p>
<ol type="1">
<li>If <em>C</em> has a product get port, then <em>C</em> <code>TesterBase</code> provides the following functions:<ol type="a">
<li><code>pushProductGetEntry</code>: This function takes a container ID and a size. It constructs the corresponding <code>DpGet</code> history object and pushes it on <code>productGetHistory</code>. Typically this function is called by <code>productGet_handler</code> (see below).</li>
</ol>
<ol type="a">
<li><code>productGet_handler</code>: This function is called when the tester component receives data emitted on the product get port of the component under test. It takes a container ID, a size, and a mutable reference to a buffer <em>B</em>. By default it calls <code>pushProductGetEntry</code> with the ID and size and returns <code>FAILURE</code>, indicating that no memory was allocated and <em>B</em> was not updated. This function is virtual, so you can override it with your own behavior. For example, your function could call <code>pushProductGetEntry</code>, allocate a buffer, store the allocated buffer into <em>B</em>, and return <code>SUCCESS</code>.</li>
</ol>
</li>
</ol>
<ol type="1">
<li>If <em>C</em> has a product request port, then <em>C</em> <code>TesterBase</code> provides the following functions:<ol type="a">
<li><code>pushProductRequestEntry</code>: This function takes a container ID and a size. It constructs the corresponding <code>DpRequest</code> history object and pushes it on <code>productRequestHistory</code>. Typically this function is called by <code>productRequest_handler</code> (see below).</li>
</ol>
<ol type="a">
<li><code>productRequest_handler</code>: This function is called when the tester component receives data emitted on the product request port of the component under test. It takes a container ID and a size. By default it calls <code>pushProductRequestEntry</code> with the ID and size. This function is virtual, so you can override it with your own behavior.</li>
</ol>
</li>
</ol>
<ol type="1">
<li><em>C</em> <code>TesterBase</code> provides the following functions:<ol type="a">
<li><code>pushProductSendEntry</code>: This function takes a container ID and a const reference to a buffer. It constructs the corresponding <code>DpSend</code> history object and pushes it on <code>productSendHistory</code>. Typically this function is called by <code>productSend_handler</code> (see below).</li>
</ol>
<ol type="a">
<li><code>productSend_handler</code>: This function is called when the tester component receives data emitted on the product send port of the component under test. It takes a container ID and a const reference to a buffer. By default it calls <code>pushProductSendEntry</code> with the ID and buffer. This function is virtual, so you can override it with your own behavior.</li>
</ol>
</li>
</ol>
<h3><a class="anchor" id="autotoc_md42"></a>
3.4.2. The GTestBase Class</h3>
<p><b>Testing macros:</b> The class <em>C</em> <code>GTestBase</code> provides the following macros for verifying the histories managed by <em>C</em> <code>TesterBase</code>.</p>
<ol type="1">
<li>If <em>C</em> defines data products and has a product get port, then <em>C</em> <code>GTestBase</code> provides the following macros:<ol type="a">
<li><code>ASSERT_PRODUCT_GET_SIZE(size)</code>: This macro checks that <code>productGetHistory</code> has the specified size (number of entries).</li>
</ol>
<ol type="a">
<li><code>ASSERT_PRODUCT_GET(index, id, size)</code>: This macro checks that <code>productGetHistory</code> has the specified container ID and size at the specified history index.</li>
</ol>
</li>
</ol>
<ol type="1">
<li>If <em>C</em> defines data products and has a product request port, then <em>C</em> <code>GTestBase</code> provides the following macros:<ol type="a">
<li><code>ASSERT_PRODUCT_REQUEST_SIZE(size)</code>: This macro checks that <code>productRequestHistory</code> has the specified size (number of entries).</li>
</ol>
<ol type="a">
<li><code>ASSERT_PRODUCT_REQUEST(index, id, size)</code>: This macro checks that <code>productRequestHistory</code> has the specified container ID and size at the specified history index.</li>
</ol>
</li>
</ol>
<ol type="1">
<li>If <em>C</em> defines data products, then <em>C</em> <code>GTestBase</code> provides the following macros:<ol type="a">
<li><code>ASSERT_PRODUCT_SEND_SIZE(size)</code>: This macro checks that <code>productSendHistory</code> has the specified size (number of entries).</li>
</ol>
<ol type="a">
<li><code>ASSERT_PRODUCT_SEND(index, id, priority, timeTag, procType, userData, dataSize, buffer)</code>: All the arguments of this macro are inputs (read-only) except <code>buffer</code>, which is a by-reference output and must be a variable of type <code><a class="el" href="class_fw_1_1_buffer.html">Fw::Buffer</a>&amp;</code>. This macro verifies the entry <code>entry</code> stored at the specified index of <code>productSendHistory</code>. It does the following:<ol type="i">
<li>Check that <code>entry.id</code> matches the specified ID.</li>
</ol>
<ol type="i">
<li>Deserialize the data product header stored in <code>entry.buffer</code>.</li>
</ol>
<ol type="i">
<li>Check that the container ID, priority, time tag, processor type, user data, and data size stored in the deserialized header match the specified values.</li>
</ol>
<ol type="i">
<li>Assign <code>entry.buffer</code> to <code>buffer</code>. After this macro runs, the deserialization pointer of <code>buffer</code> points into the start of the data payload of <code>entry.buffer</code>. You can write additional code to deserialize and check the data payload.</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><b>Container IDs:</b> The container IDs emitted by the component under test are global IDs. Therefore, when constructing specified IDs you must add the ID base specified in the tester component to the local ID specified in the component under test. For example, for container <code>CONTAINER</code> in component <code>Component</code>, you would write </p><div class="fragment"><div class="line">ID_BASE + Component::ContainerId::CONTAINER</div>
</div><!-- fragment --><p> <code>ID_BASE</code> is a standard constant defined in each Tester implementation and provided to the Tester base classes in their constructors.</p>
<h1><a class="anchor" id="autotoc_md43"></a>
4. Use Cases</h1>
<p>In this section we discuss several common use cases involving data products.</p>
<p><b>Requesting and sending data products:</b> See the example uses in the documentation for <a href="../../Svc/DpManager/docs/sdd.md#5-example-uses"><code>Svc::DpManager</code></a>. The component referred to as <code>producer</code> in that document is a data product producer.</p>
<p><b>Writing data products to non-volatile storage:</b> See the example uses in the documentation for <a href="../../Svc/DpWriter/docs/sdd.md#6-example-uses"><code>Svc::DpWriter</code></a>. The component referred to as <code>producer</code> in that document is a data product producer.</p>
<p><b>Cataloging and downlinking data products:</b> For a preliminary implementation of the data product catalog, see <a class="el" href="svc_2_dp_catalog_2docs_2sdd_8md.html">`Svc::DpCatalog`</a>.</p>
<p><b>Processing data products:</b> TODO </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
