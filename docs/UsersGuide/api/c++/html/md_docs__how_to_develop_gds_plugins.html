<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>F´ Flight Software - C/C++ Documentation: How-To: F´ GDS Plugin Development</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">F´ Flight Software - C/C++ Documentation
   &#160;<span id="projectnumber">devel</span>
   </div>
   <div id="projectbrief">A framework for building embedded system applications to NASA flight quality standards.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_docs__how_to_develop_gds_plugins.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">How-To: F´ GDS Plugin Development </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This guide will walk through the process of developing GDS plugins. GDS plugins allow users to add functionality to the GDS in several ways. These include:</p>
<ol type="1">
<li>Selection plugins: add another choice for key GDS functionality</li>
<li>Functionality plugins: add functionality as an addition to the GDS.</li>
</ol>
<p>This guide will walk through the development of a <code>framing</code> selection plugin to see the basic development of a plugin. Then the guide will walk you through the development of a start-up application functionality plugin, which will also discuss taking arguments to plugins. Finally the guide will close with a discussion of testing and distributing your plugins.</p>
<p>Examples covered here are available at: <a href="https://github.com/fprime-community/fprime-gds-plugin-examples">https://github.com/fprime-community/fprime-gds-plugin-examples</a></p>
<h1><a class="anchor" id="autotoc_md111"></a>
Contents</h1>
<ul>
<li><a href="#plugin-system-design">Plugin System Design</a></li>
<li><a href="#developing-a-plugin">Developing a Plugin</a><ul>
<li><a href="#basic-plugin-skeleton">Basic Plugin Skeleton</a></li>
<li><a href="#implementing-virtual-functions">Implementing Virtual Functions</a></li>
</ul>
</li>
<li><a href="#application-plugins">Application Plugins</a><ul>
<li><a href="#application-plugin-skeleton">Application Plugin Skeleton</a></li>
<li><a href="#plugin-arguments">Plugin Arguments</a></li>
</ul>
</li>
<li><a href="#packaging-and-testing-plugins">Packaging and Testing Plugins</a></li>
<li><a href="#distributing-plugins">Distributing Plugins</a></li>
<li><a href="#conclusion">Conclusion</a></li>
</ul>
<h1><a class="anchor" id="autotoc_md112"></a>
Plugin System Design</h1>
<p>GDS plugins are built on top of the <a href="https://pluggy.readthedocs.io/en/stable/">pluggy</a>. This means that each implementor of a GDS plugin must define a function for behavior and mark that function with an implementation decorator. GDS plugins all define a registration function, which returns an implementation class for the given plugin category.</p>
<p>The GDS defines several categories of plugins that the user may implement. These categories and the plugin type of each category is summarized in the table below.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Category   </th><th class="markdownTableHeadNone">Type   </th><th class="markdownTableHeadNone">Description   </th><th class="markdownTableHeadNone">Implementation Base Class    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">framing   </td><td class="markdownTableBodyNone">Selection   </td><td class="markdownTableBodyNone">Implement a framer/deframer pair to handle serialized data   </td><td class="markdownTableBodyNone"><a href="https://github.com/fprime-community/fprime-gds/blob/devel/src/fprime_gds/common/communication/framing.py#L24">FramerDeframer</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">communication   </td><td class="markdownTableBodyNone">Selection   </td><td class="markdownTableBodyNone">Implement a communication adapter for flight software communication   </td><td class="markdownTableBodyNone"><a href="https://github.com/fprime-community/fprime-gds/blob/devel/src/fprime_gds/common/communication/adapters/base.py#L16">BaseAdapter</a>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">gds-app   </td><td class="markdownTableBodyNone">Functionality   </td><td class="markdownTableBodyNone">Implement a new GDS application isolated to a separate process   </td><td class="markdownTableBodyNone"><a href="https://github.com/fprime-community/fprime-gds/blob/devel/src/fprime_gds/executables/apps.py#L76">GdsApp</a>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">gds-function   </td><td class="markdownTableBodyNone">Functionality   </td><td class="markdownTableBodyNone">(Advanced) Implement new GDS functionality with control over the process   </td><td class="markdownTableBodyNone"><a href="https://github.com/fprime-community/fprime-gds/blob/devel/src/fprime_gds/executables/apps.py#L40">GdsFunction</a>   </td></tr>
</table>
<p>Plugins should define a function called <code>register_&lt;category&gt;_plugin</code> that return a concrete subclass of the category's implementation base class from the above table. These concrete classes may additionally define <code>get_arguments</code>, <code>get_name</code>, and <code>check_arguments</code> functions used by the plugin system to provide and validate arguments from the CLI.</p>
<p>This guide will walk through the development of a framing plugin and compare that to a gds-app plugin.</p>
<h1><a class="anchor" id="autotoc_md113"></a>
Developing a Plugin</h1>
<p>The first step in developing a framing plugin is to determine the function that must be implemented and the class that must be derived to develop the plugin. For the case of a <code>framing</code> plugin, the <code>register_framing_plugin</code> function must be defined to return a concrete subclass of <code>FramerDeframer</code>. This information was found in the above table.</p>
<h2><a class="anchor" id="autotoc_md114"></a>
Basic Plugin Skeleton</h2>
<p>GDS plugins define a class that inherits from the implementation base class and implements all virtual functions. These classes also define a properly decorated class method for the registration function, and may define the other class methods used for CLI interaction.</p>
<p>A basic framing plugin skeleton would thus look like: **<code>src/my_plugin.py</code>:** </p><div class="fragment"><div class="line">from fprime_gds.common.communication.framing import FramerDeframer</div>
<div class="line">from fprime_gds.plugin.definitions import gds_plugin_implementation</div>
<div class="line"> </div>
<div class="line">class MyPlugin(FramerDeframer):</div>
<div class="line">    # TODO: implement virtual functions</div>
<div class="line">    @classmethod</div>
<div class="line">    def get_name(cls):</div>
<div class="line">        &quot;&quot;&quot; Name of this implementation provided to CLI &quot;&quot;&quot;</div>
<div class="line">        return &quot;my-plugin&quot;</div>
<div class="line"> </div>
<div class="line">    @classmethod</div>
<div class="line">    def get_arguments(cls):</div>
<div class="line">        &quot;&quot;&quot; Arguments to request from the CLI &quot;&quot;&quot;</div>
<div class="line">        return {}</div>
<div class="line"> </div>
<div class="line">    @classmethod</div>
<div class="line">    def check_arguments(cls):</div>
<div class="line">        &quot;&quot;&quot; Check arguments from the CLI &quot;&quot;&quot;</div>
<div class="line">        pass</div>
<div class="line"> </div>
<div class="line">    @classmethod</div>
<div class="line">    @gds_plugin_implementation</div>
<div class="line">    def register_framing_plugin(cls):</div>
<div class="line">        &quot;&quot;&quot; Register the MyPlugin plugin &quot;&quot;&quot;</div>
<div class="line">        return cls</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md115"></a>
Implementing Virtual Functions</h2>
<p>Each plugin implementation base class (e.g. <code>FramerDeframer</code>) has a set of virtual methods that plugin implementors <em>must</em> implement in order to support the plugin implementation. These functions are marked as <code>@abc.abstractmethod</code> and can be found in the virtual class definition.</p>
<p><a href="https://github.com/fprime-community/fprime-gds/blob/devel/src/fprime_gds/common/communication/framing.py#L29-L51">FramerDeframer virtual functions</a> consist of a <code>frame</code> and <code>deframe</code> method. Below the frame function adds the bytes <code>MY-PLUGIN</code> to the start of each frame and strip the same bytes off the start of each frame. This is a trivial example of a start word.</p>
<p>**<code>src/my_plugin.py</code>:** </p><div class="fragment"><div class="line">from fprime_gds.common.communication.framing import FramerDeframer</div>
<div class="line">from fprime_gds.plugin.definitions import gds_plugin_implementation</div>
<div class="line"> </div>
<div class="line">class MyPlugin(FramerDeframer):</div>
<div class="line">    START_TOKEN = b&quot;MY-PLUGIN&quot;</div>
<div class="line">    </div>
<div class="line">    def frame(self, data):</div>
<div class="line">        &quot;&quot;&quot; Frames data with &#39;MY-PLUGIN&#39; start token &quot;&quot;&quot;</div>
<div class="line">        return self.START_TOKEN + data</div>
<div class="line"> </div>
<div class="line">    def deframe(self, data, no_copy=False):</div>
<div class="line">        &quot;&quot;&quot; Deframe data with &#39;MY-PLUGIN&#39; start token &quot;&quot;&quot;</div>
<div class="line">        discarded = b&quot;&quot;</div>
<div class="line">        data = data if no_copy else b&quot;&quot; + data # Copy data if no_copy</div>
<div class="line">        </div>
<div class="line">        # Deframing can deframe until data length isn&#39;t enough to provide start token</div>
<div class="line">        while len(data) &gt; len(self.START_TOKEN):</div>
<div class="line">            # Starts with start word and a second start word found</div>
<div class="line">            if data[:len(self.START_TOKEN)] == self.START_TOKEN and self.START_TOKEN in data[1:]:</div>
<div class="line">                data = data[len(self.START_TOKEN):] # Remove initial start token</div>
<div class="line">                # Return packet (data to next start token), unconsumed data, and discarded data</div>
<div class="line">                return data[:data.index(self.START_TOKEN)], data[data.index(self.START_TOKEN):], discarded</div>
<div class="line">            # Starts with start token, but beginning of next packet was not found</div>
<div class="line">            elif data[:len(self.START_TOKEN)] == self.START_TOKEN:</div>
<div class="line">                # Wait for new data</div>
<div class="line">                break</div>
<div class="line">            # Does not start with requested token throw away one byte and continue</div>
<div class="line">            else:</div>
<div class="line">                discarded += data[1]</div>
<div class="line">                data[1:]</div>
<div class="line">                continue</div>
<div class="line">        # No packet found, all data unconsumed, and discarded</div>
<div class="line">        return None, data, discarded</div>
<div class="line">    </div>
<div class="line">    @classmethod</div>
<div class="line">    def get_name(cls):</div>
<div class="line">        &quot;&quot;&quot; Name of this implementation provided to CLI &quot;&quot;&quot;</div>
<div class="line">        return &quot;my-plugin&quot;</div>
<div class="line"> </div>
<div class="line">    @classmethod</div>
<div class="line">    def get_arguments(cls):</div>
<div class="line">        &quot;&quot;&quot; Arguments to request from the CLI &quot;&quot;&quot;</div>
<div class="line">        return {}</div>
<div class="line"> </div>
<div class="line">    @classmethod</div>
<div class="line">    def check_arguments(cls):</div>
<div class="line">        &quot;&quot;&quot; Check arguments from the CLI &quot;&quot;&quot;</div>
<div class="line">        pass</div>
<div class="line"> </div>
<div class="line">    @classmethod</div>
<div class="line">    @gds_plugin_implementation</div>
<div class="line">    def register_framing_plugin(cls):</div>
<div class="line">        &quot;&quot;&quot; Register the MyPlugin plugin &quot;&quot;&quot;</div>
<div class="line">        return cls</div>
</div><!-- fragment --><p>This is the basic implementation of a no-argument framing plugin. The above plugin tracks a single start <code>MY-PLUGIN</code> string and deframes that as a packet. Next, this guide will cover how to integrate this plugin via python packaging. Following that, plugin arguments will be covered.</p>
<p>You may now continue to read about "Application Plugins" that show the other type of plugin available for the <code>fprime-gds</code>. This section also covers how arguments to plugins work. Otherwise, jump to the <a href="#packaging-and-testing-plugins">Packaging and Testing Plugins</a> section to begin testing your plugin!</p>
<h1><a class="anchor" id="autotoc_md116"></a>
Application Plugins</h1>
<p>Unlike the example <code>framing</code> plugin, application plugins run in addition to the GDS. These plugins can be used to start new services that connect to the larger GDS network. Application plugins will be used to show how to solicit arguments from the command line.</p>
<p>Our plugin ill run python to print a message supplied via arguments. This is the equivalent to running the following command line: </p><div class="fragment"><div class="line">python -c &quot;print(&#39;Hello World&#39;)&quot;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md117"></a>
Application Plugin Skeleton</h2>
<p>Here is the basic structure for a <code>gds-app</code> plugin. It prints "Hello World". gds-app plugins must implement the function <code>get_process_invocation</code> that returns command line arguments to be run as a separate process using the <code>subprocess</code> module.</p>
<p>**<code>src/my_app.py</code>:** </p><div class="fragment"><div class="line">import sys</div>
<div class="line">from fprime_gds.executables.apps import GdsApp</div>
<div class="line"> </div>
<div class="line">class MyApp(GdsApp):</div>
<div class="line">    &quot;&quot;&quot; An app for the GDS &quot;&quot;&quot;</div>
<div class="line"> </div>
<div class="line">    def get_process_invocation(self):</div>
<div class="line">        &quot;&quot;&quot; Process invocation &quot;&quot;&quot;</div>
<div class="line">        return [sys.executable, &quot;-c&quot;, &quot;print(&#39;Hello World&#39;)&quot;]</div>
<div class="line"> </div>
<div class="line">    @classmethod</div>
<div class="line">    def get_name(cls):</div>
<div class="line">        &quot;&quot;&quot; Get name &quot;&quot;&quot;</div>
<div class="line">        return &quot;my-app&quot;</div>
<div class="line"> </div>
<div class="line">    @classmethod</div>
<div class="line">    @gds_plugin_implementation</div>
<div class="line">    def register_gds_app_plugin(cls):</div>
<div class="line">        &quot;&quot;&quot; Register a good plugin &quot;&quot;&quot;</div>
<div class="line">        return cls</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md118"></a>
Plugin Arguments</h2>
<p>Plugins can source arguments from the command line. Although, all types of plugins can source arguments using the pattern described here, you will see them shown with our application plugin.</p>
<p>It is time to add in plugin arguments. This plugin will take one argument <code>--message</code> and will inject this message into the printed message. To do this we return the argument using the <code>get_arguments</code> class method. Add this to your plugin <code>MyApp</code> class:</p>
<div class="fragment"><div class="line">@classmethod</div>
<div class="line">def get_arguments(cls):</div>
<div class="line">  &quot;&quot;&quot; Get arguments &quot;&quot;&quot;</div>
<div class="line">  return {</div>
<div class="line">    (&quot;--message&quot;, ): {</div>
<div class="line">      &quot;type&quot;: str,</div>
<div class="line">      &quot;help&quot;: &quot;Message to print&quot;,</div>
<div class="line">      &quot;required&quot;: True</div>
<div class="line">    }</div>
<div class="line">  }</div>
</div><!-- fragment --><p><code>get_arguments</code> is a class method that returns a dictionary whose keys are tuples containing the flags, and whose value is a dictionary of keyword arguments passed to <a href="https://docs.python.org/3/library/argparse.html#the-add-argument-method"><code>argparse.add_argument</code></a>.</p>
<p>Arguments are supplied to the plugin at instantiation via keyword arguments. Add the following to your <code>MyApp</code> class.</p>
<div class="fragment"><div class="line">def __init__(self, message):</div>
<div class="line">    &quot;&quot;&quot; Constructor &quot;&quot;&quot;</div>
<div class="line">    super().__init__()</div>
<div class="line">    self.message = message</div>
</div><!-- fragment --><p>Change the <code>get_process_invocation</code> to use the new member variable.</p>
<div class="fragment"><div class="line">def get_process_invocation(self):</div>
<div class="line">    &quot;&quot;&quot; Process invocation &quot;&quot;&quot;</div>
<div class="line">    # Inject message into command line to print</div>
<div class="line">    return [sys.executable, &quot;-c&quot;, f&quot;print(f&#39;{self.message}&#39;)&quot;]</div>
</div><!-- fragment --><p>Finally, security-minded developers will notice there is an injection vulnerability above. This can be check using the <code>check_arguments</code> class method. This method should raise a <code>ValueError</code> or <code>TypeError</code> when an argument value is malformed. Add this function to <code>MyApp</code> fix the injection:</p>
<div class="fragment"><div class="line">@classmethod</div>
<div class="line">def check_arguments(cls, message):</div>
<div class="line">    &quot;&quot;&quot; Check arguments &quot;&quot;&quot;</div>
<div class="line">    if &quot;&#39;&quot; in message or &#39;\n&#39; in message:</div>
<div class="line">        raise ValueError(&quot;--message must not include &#39; nor a newline&quot;)</div>
</div><!-- fragment --><p>Now our plugin may be run. The GDS will automatically solicit the message argument as seen should the user run </p><div class="fragment"><div class="line">fprime-gds --help</div>
</div><!-- fragment --><p>The complete plugin would look like:</p>
<p>**<code>src/my_app.py</code>:** </p><div class="fragment"><div class="line">import sys</div>
<div class="line">from fprime_gds.plugin.definitions import gds_plugin_implementation</div>
<div class="line">from fprime_gds.executables.apps import GdsApp</div>
<div class="line"> </div>
<div class="line">class MyApp(GdsApp):</div>
<div class="line">    &quot;&quot;&quot; An app for the GDS &quot;&quot;&quot;</div>
<div class="line"> </div>
<div class="line">    def __init__(self, message):</div>
<div class="line">        &quot;&quot;&quot; Constructor &quot;&quot;&quot;</div>
<div class="line">        super().__init__()</div>
<div class="line">        self.message = message</div>
<div class="line"> </div>
<div class="line">    def get_process_invocation(self):</div>
<div class="line">        &quot;&quot;&quot; Process invocation &quot;&quot;&quot;</div>
<div class="line">        # Inject message into command line to print</div>
<div class="line">        return [sys.executable, &quot;-c&quot;, f&quot;print(f&#39;{self.message}&#39;)&quot;]</div>
<div class="line"> </div>
<div class="line">    @classmethod</div>
<div class="line">    def get_name(cls):</div>
<div class="line">        &quot;&quot;&quot; Get name &quot;&quot;&quot;</div>
<div class="line">        return &quot;my-app&quot;</div>
<div class="line">    </div>
<div class="line">    @classmethod</div>
<div class="line">    def get_arguments(cls):</div>
<div class="line">        &quot;&quot;&quot; Get arguments &quot;&quot;&quot;</div>
<div class="line">        return {</div>
<div class="line">            (&quot;--message&quot;, ): {</div>
<div class="line">                &quot;type&quot;: str,</div>
<div class="line">                &quot;help&quot;: &quot;Message to print&quot;,</div>
<div class="line">                &quot;required&quot;: True</div>
<div class="line">            }</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">    @classmethod</div>
<div class="line">    def check_arguments(cls, message):</div>
<div class="line">        &quot;&quot;&quot; Check arguments &quot;&quot;&quot;</div>
<div class="line">        if &quot;&#39;&quot; in message or &#39;\n&#39; in message:</div>
<div class="line">            raise ValueError(&quot;--message must not include &#39; nor a newline&quot;)</div>
<div class="line">  </div>
<div class="line">    @classmethod</div>
<div class="line">    @gds_plugin_implementation</div>
<div class="line">    def register_gds_app_plugin(cls):</div>
<div class="line">        &quot;&quot;&quot; Register a good plugin &quot;&quot;&quot;</div>
<div class="line">        return cls</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md119"></a>
Packaging and Testing Plugins</h1>
<p>Plugins are supplied as python packages with an entrypoint used to load the plugin. In the root of the package a basic python package will need to be configured. This consists of two files: pyproject.toml representing the package, and setup.py for backwards compatibility.</p>
<p>The project structure should look like: </p><div class="fragment"><div class="line">src/my_plugin.py</div>
<div class="line">pyproject.toml</div>
<div class="line">setup.py</div>
</div><!-- fragment --><p>A sample pyproject.toml file would look like:</p>
<div class="fragment"><div class="line">[build-system]</div>
<div class="line">requires = [&quot;setuptools&quot;, &quot;wheel&quot;]</div>
<div class="line">build-backend = &quot;setuptools.build_meta&quot;</div>
<div class="line"> </div>
<div class="line">[project]</div>
<div class="line">name = &quot;fprime-gds-my-plugin&quot;</div>
<div class="line">version = &quot;0.1.0&quot;</div>
<div class="line">dependencies = [</div>
<div class="line">    &quot;pluggy&gt;=1.3.0&quot;,</div>
<div class="line">    &quot;fprime-gds&gt;=3.4.4&quot;</div>
<div class="line">]</div>
<div class="line"> </div>
<div class="line">[project.entry-points.fprime_gds]</div>
<div class="line">my_plugin = &quot;my_plugin:MyPlugin&quot;</div>
<div class="line"> </div>
<div class="line">[tool.setuptools_scm]</div>
</div><!-- fragment --><p>A sample <code>setup.py</code> would look like: </p><div class="fragment"><div class="line">from setuptools import setup</div>
<div class="line"> </div>
<div class="line"># Configuration is in pyproject.toml</div>
<div class="line">setup()</div>
</div><!-- fragment --><p>We can add our application plugin with the following additional line in the <code>project.entry-points.fprime_gds</code> section:</p>
<div class="fragment"><div class="line">my_app = &quot;my_app:MyApp&quot;</div>
</div><!-- fragment --><p>Once these files have been written, the plugin can be installed locally for testing with the following command:</p>
<div class="fragment"><div class="line">cd /path/to/plugin/directory</div>
<div class="line">pip install -e .</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>Users must be in the same virtual environment that the <code>fprime-gds</code> package has been installed into <code>-e</code> allows local changes to take effect without a reinstall </p>
</blockquote>
<p>The first step in testing a plugin is to run <code>fprime-gds --help</code>. This should show arguments associated with your plugin. The plugins implemented here would produce the following output:</p>
<div class="fragment"><div class="line">usage: fprime-gds ...</div>
<div class="line">...</div>
<div class="line">Framing Plugin Options:</div>
<div class="line">  --framing-selection {fprime,my-plugin}</div>
<div class="line">                        Select framing implementer. (default: fprime)</div>
<div class="line">...</div>
<div class="line">Gds_App Plugin &#39;my-app&#39; Options:</div>
<div class="line">  --disable-my-app      Disable the gds_app plugin &#39;my-app&#39; (default: False)</div>
<div class="line">  --message MESSAGE     Message to print (default: None)</div>
</div><!-- fragment --> <blockquote class="doxtable">
<p>Syntax errors, indentation errors, and other exceptions can arise during this step. Resolving these errors will allow the help message to display properly. </p>
</blockquote>
<p>To test selection plugins, select them during a normal GDS run:</p>
<div class="fragment"><div class="line">fprime-gds --framing-selection my-plugin</div>
</div><!-- fragment --> <blockquote class="doxtable">
<p>Remember to supply any arguments needed for your plugin! </p>
</blockquote>
<p>Application plugins run automatically at start-up. To test these plugins, just supply any desired arguments:</p>
<div class="fragment"><div class="line">fprime-gds --message &quot;Hello Plugin</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md120"></a>
Distributing Plugins</h1>
<p>Plugins are implemented as python packages. Thus plugins may be distributed in the following ways:</p>
<ol type="1">
<li>Source Distribution: send users your source code and install with <code>pip install .</code> as shown above</li>
<li>Binary Distribution: send users a wheel of your package to install with <code>pip install /path/to/wheel</code></li>
<li>PyPI: distribute your wheel via PyPI</li>
</ol>
<p>A tutorial on python packaging including building wheels and uploading them to PyPI is available from packaging.python.org: <a href="https://packaging.python.org/en/latest/tutorials/packaging-projects/">https://packaging.python.org/en/latest/tutorials/packaging-projects/</a></p>
<h1><a class="anchor" id="autotoc_md121"></a>
Conclusion</h1>
<p>This guide has covered how to develop GDS plugins, their design, and selection vs functionality plugins. You should now be capable of writing plugins and handling arguments. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
